
<!-- saved from url=(0050)http://beta.cs.byu.edu/~cs235/labs/lab3-boggle.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>
Boggle
</title>


<meta http-equiv="content-script-type" content="text/javascript">
<meta http-equiv="content-style-type" content="text/css">

<link rel="stylesheet" type="text/css" media="screen,projection" href="./Boggle_lab_files/style.css">

</head>
<body>

<div class="box">
<h1>
Computer Science 235
</h1>
</div>

<div class="main">

<div class="center">
<h2>
Boggle
</h2>
</div>
<hr>

<p>
Note: Projects are to be completed by each student individually
(not by groups of students).
</p>


<p>
The objective of this project is to design and implement
the data structures and algorithms necessary for
a computer player to play the popular board game Boggle.
</p>



<h3>
What is Boggle?
</h3>

<p>
The game of Boggle is played with a set of sixteen letter cubes,
which are standard six-sided dice
except that they are marked with letters of
the alphabet instead of numbers.
The cubes are rolled and arranged into
a 4x4 square that might look like this:
</p>

<p>
<img width="193" height="193" src="./Boggle_lab_files/image002.gif">
</p>

<p>
The object of the game is to start at one cube
and then work through a chain of letters to form
a word that meets the following conditions:
</p>

<ul>

<li>
The word must be at least four letters long.

</li><li>
The path traced out by the letters in the word must be
connected horizontally, vertically, or diagonally.
You can't skip over intervening cubes to get the next letter.

</li><li>
Each cube may be used only once in a given word.

</li></ul>

<p>
For example, the sample board contains the word
<b>PEACE</b>
as follows:
</p>

<p>
<img width="193" height="193" src="./Boggle_lab_files/image004.gif">
</p>

<p>
The board, however, does not contain the word
<b>PLACE</b>
which would require jumping from the
<b>P</b>
to the
<b>L</b>
and then back to the
<b>A</b>
.

Similarly, it is not possible to make the word
<b>POPE</b>
,
because doing so would require reusing the
<b>P</b>
.
</p>


<p>
The Boggle player you create will find and output
all the valid words on a given board.
Valid words are those listed in a given dictionary.
</p>



<h3>
Example Inputs
</h3>

<p>
The Boggle player is given a dictionary
and a board configuration as inputs.
</p>


<h4>
Dictionary
</h4>

<pre>blue
boot
booth
cat
dog
orbit
riot
robot
root
run
</pre>


<h4>
Board
</h4>

<pre>
R B 
 O O I

T  R O H 

</pre>


<h3>
Example Output
</h3>

<p>
The Boggle player outputs the board in a standard format
followed by the set of the words found on the board.
</p>

<pre>r b o
o i t
r o h

boot
booth
orbit
riot
robot
root
</pre>



<h3>
Testing
</h3>

<p>
Here are some ideas for tests.
</p>

<ol>
<li>
An empty dictionary file.
</li><li>
Boards of various sizes such as 3x3, 4x4, and 5x5.
</li><li>
A board with a word that is shorter than length 4.
</li><li>
A board with a word made by reusing tiles.
</li><li>
A board with a word made by skipping tiles.
</li></ol>



<h3>
Dictionary File Format
</h3>

<p>
The dictionary is a text file that contains
a list of words, one word per line.
When comparing words on the board
with words in the dictionary,
use a comparison that is not case-sensitve.
</p>


 
<h3>
Boggle Board Files
</h3>

<p>
The Boggle board is a text file that contains
a list of strings separated by white space.
Each string gives the letter(s) for one of the
tiles on the Boggle board.
</p>

<p>
The number of strings in the file will always be
a perfect square such as 9, 16, or 25.
(The board will always be square.)
In standard Boggle the number of tiles is 16
(a 4x4 board).
Your Boggle player needs to work correctly
with a square board of any size.
</p>

<p>
The strings in the file are organized by row.
The strings for the first board-row are given first
followed by the strings for the second row.
The strings for the last row on the board come last.
Within each row the strings are listed from left to right.
The first string in the file gives the letter(s)
on the tile at the upper left corner of the board.
The last string in the file gives the letter(s)
on the tile at the bottom right corner of the board.
</p>

<p>
Line breaks may appear in the board file
between any two tile strings.
They do not always occur at the end of a board-row.
</p>

<p>
Each string in the board file may be upper or lower case
and may contain one or more letters.
In official Boggle, each tile contains only one letter,
(except for one tile that contains 'Qu').
Your Boggle player needs to work correctly
with strings of any length.
</p>



<h3>
Output Format
</h3>

<p>
The output consists of the board that was read from the input
followed by the set of words found on the board.
There is a single blank line between
the board output and the set of found words.
(There are no blank lines within the board output
and there are no blank lines within the set of words.)
</p>



<h3>
Board Output Format
</h3>

<p>
The tiles on the board are output
in the same order they were read from the input.
Each row of tiles on the board is
output on a separate line.
There is a line-break in the output
at the end of each board-row.
There are no line-breaks in the middle of a board-row.
Each tile on a board-row is separated from
the previous tile on the row by a single space.
The tiles on the board are output in lower case.
</p>



<h3>
Found Words Output Format
</h3>

<p>
The words found on the Boggle board
are output one word per line.
Each word given in the output must be:
</p>

<ol>

<li>
found in the dictionary

</li><li>
at least the minimum length of 4 letters

</li><li>
found on the board following the standard Boggle rules.
(Each tile can participate at most once in a given word.)

</li></ol>

<p>
The words are output in sorted order.
</p>

<p>
The words are output in lower case.
</p>

<p>
Each word is only output once even though
the board may contain the same word
in multiple locations.
</p>



<h3>
Dictionary Operations
</h3>

<p>
If Boggle is to run in a reasonable amount of time,
the operations for searching the dictionary
must be fast, even for large dictionaries.
</p>

<p>
One way to make the search fast is to store the
dictionary in a Set and use the Set find operation
to search for a word.
The find operation for a Set is
typically a fast operation.
</p>

<!--
<p>
Another way to make the search fast is to store
the dictionary in a sorted List and use a
binary search algorithm to search for a word.
You would need to use a type of List that supports
efficient indexing (such as a vector).
</p>
-->

<p>
When searching the Boggle board for words you will
need to stop following a path whenever you can
determine that the first part of the path does
not match a prefix of any word in the dictionary.
Thus you need to be able to search the dictionary
for prefixes and the prefix search must be fast.
</p>

<p>
If the dictionary is stored in a Set,
many Sets provide a way to find the string
in the Set that is closest to the one
you are searching for.
Such an operation could be used to quickly find
a word with a given prefix.
</p>

<!--
<p>
If the dictionary is stored in a sorted List,
the binary search algorithm can be modified
to find the string in the List that is closest
to the one you are searching for.
</p>
-->



<h3>
Word Search Operations
</h3>

<p>
You are required to find the words on the board
using a recursive search over the paths on the board.
Of course, there are many paths to be followed.
If Boggle is to run in a reasonable amount of time,
your algorithm will need to be intelligent about
avoiding wasted effort.
One way to speed up the search is to only follow paths
that have the possibility of leading to valid words.
Before moving along a path, the search algorithm should
ask the dictionary if any words begin with the
prefix represented by the current path.
If the answer is no, there is no need to follow the path further.
Checking prefixes in this manner will allow your algorithm
to avoid many dead-end paths, and therefore run more quickly.
In fact, if you don't do this, your program will
run too slowly to pass off.
</p>



<h3>
Implementation Requirements
</h3>

<ol>

<li>
Store the dictionary in a Set.
<!--
Store the dictionary in a Set or a sorted List.
-->

</li><li>
Use a fast set operation
<!--
Use either a set operation or binary search
-->
to locate a word in the dictionary that is closest
to a given prefix.

</li><li>
Use a recursive search over the contents of
the board to find the words.

</li><li>
Use a compare that is not case-sensitive
when comparing words on the board
with words in the dictionary.

</li><li>
Output the words in sorted order.

</li><li>
Output the words in lower case.

</li><li>
Avoid following dead-end paths,
thus allowing Boggle to run quickly on large boards.

</li><li>
Your implementation needs to run with large boards
and large dictionaries
in a reasonable amount of time.

</li></ol>



<h3>
Command Line
</h3>

<p>
The program is run with the names of the
dictionary, board, and output
files given on the command-line.
For example the program might be run like this:
</p>

<pre>lab3 dictionary.txt board.txt output.txt
</pre>



</div>





</body></html>